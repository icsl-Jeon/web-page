---
title: How to organize ROS project - design pattern
date: 2023-04-27
description:
  When collaborating with others on a software project, it's important to ensure
  that the codebase is consistent and well-formatted. This can be achieved
  through the use of code formatting tools such as cmake-format and
  clang-format. cmake-format is a tool that helps to format CMake files in a
  consistent and readable manner. clang-format, on the other hand, is a tool
  that can be used to format C++, Java, JavaScript, and other code in a
  consistent style. By using these tools, developers can ensure that the
  codebase is consistent and easy to read, which can make it easier for other
  developers to understand and work with the code. This can be especially
  important when working on large projects with many contributors, where
  inconsistent formatting can lead to confusion and errors.
thumbnail: /images/post5/main.png
keywords: ros, cmake, design-pattern
---

import Image from "next/image";
import Frontmatter from "../components/Frontmatter";
import Comment from "../components/Comment";

# How to Organize ROS Project - Design Pattern

<Frontmatter />

Look at some of famous projects including ROS interface:
[octomap](https://github.com/OctoMap/octomap_ros),
[voxblox](https://github.com/ethz-asl/voxblox),
[cartographer](https://github.com/orgs/cartographer-project/repositories), and
[zed](https://github.com/stereolabs). Can you guess what is shared between them?
They tried to separate their core logic from ROS either by separating the
repository or directories. In this article, we will walkthrough why it is
important and how to setup the file structure and `CMakeList.txt` for your
project.

## 1. ROS as adapter, not entangler

### What is adapter ?

[_Adapter_](https://refactoring.guru/design-patterns/adapter) is a very famous
design pattern, which can be understood with the following words: wrapper,
interface, bridge,or interpreter. The below is a very compact example. Here,
`Game.cpp` can be seen as a client code, which knows only `GameAsset` class. To
perform some `my_core_logic` encapsulated inside `GameAsset`, we follow the
below adapter pattern.

```cpp filename="AdapterForGame.hpp" {1,2,7}
#include "my_core_logic.hpp"
class AdapterForGameEditor: public GameAsset {
  public:
    void run() override;
  ...
  private:
    CoreLogic core_logic_;
  ...
}
```

```cpp filename="AdapterForGame.cpp"
void AdapterForGameEditor::run() {
  core_logic_.run();
}
```

```cpp filename="Game.cpp"
#include "AdapterForGame.hpp"
GameAsset* asset_with_core_logic = new AdapterForGameEditor();
asset_with_core_logic->run();
```

### ROS node can be also an adapter

In a very similar manner, we can easily
[find](https://github.com/stereolabs/zed-ros2-wrapper/blob/master/zed_components/src/zed_camera/include/zed_camera_component.hpp)
the below adapter pattern code.

```cpp {1,2,9}
#include <sl/Camera.hpp> // core (~ adaptee)
class ZedCamera : public rclcpp::Node{ // base class having ROS interfacing
  ...
  //
  image_transport::CameraPublisher mPubRgb; // some publishers
  clickedPtSub mClickedPtSub; // some subscriber

  ...
  sl::Camera mZed; // core class from
}
```

As you can see, some core header is included as a member of ROS node, while the
ros node has interface derived from `Node`.

### ROS and core logic on same file? Only if you are 100% sure that ROS is only outlet

Let us assume that we have a core logic and it should be shipped to various
platforms. This is the case for [ZED](https://github.com/stereolabs) SDK which
should be delivered to [Unity](https://github.com/stereolabs/zed-unity),
[Unreal](https://github.com/stereolabs/zed-UE5),
[H-hub](https://github.com/stereolabs/zed-hub-examples), and
[ROS 2](https://github.com/stereolabs/zed-ros2-wrapper),... If you are in a
similar situation, it is insane if you entangle ROS code and pure logic which
should be reused across different outlet. Of course, ZED did not go that way.
See this picture:

<Image
  src="/images/post5/adapter.png"
  width={1000}
  height={1000}
  className="my-3"
/>

### So, what is the direction?

> I will assume you are using ROS2 with `ament_cmake`. I prepared a template
> repository [here](https://github.com/icsl-Jeon/simple-ros2-package).

Simple: **YOUR CORE LOGIC SHOULD RUN WITHOUT ROS**. Your aim is to make your
logics reusable across many outlets. This entails the followings:

- Your core logic inside a pure CMakeList project for easy reusability, not
  [catkin](https://wiki.ros.org/catkin) or
  [ament](https://design.ros2.org/articles/ament.html) formed package.
- You have two different directories and projects: 1) `core` and 2)
  `ros wrapper`.
- `ros wrapper` does not build `core`. It only finds and uses it.
- For your development convenience, `core` and `ros wrapper` could be built with
  a single build command (`colcon build` or `catkin_make`)on a same workspace.
- Testing your logic should be possible without ROS (this will be covered from
  another article in the future).

Now, I will introduce how to setup folder structure and write `CMakeLists.txt`
for `core` and `ros wrapper`.

## 2. Possible file structure

> _Disclaimer: I will discuss file structure affecting our build process, rather
> than `launch` and `param` folders._

If we looking to my [repo](https://github.com/icsl-Jeon/simple-ros2-package),
there is one possible folder tree to achieve
[aforementioned direction](/post5#so-what-is-the-direction). I personally
motivated by [voxblox repository](https://github.com/ethz-asl/voxblox).

```
~/ros2_ws/src/simple-ros2-package/
├── my_package
│   ├── CMakeLists.txt
│   ├── library_a
│   │   ├── LibraryA.cpp
│   │   └── LibraryA.hpp
│   └── library_b
│       ├── LibraryB.cpp
│       └── LibraryB.hpp
├── my_package_ros2
│   ├── CMakeLists.txt
│   ├── main.cpp
│   ├── package.xml
│   ├── visualizer
│   │   ├── Visualizer.cpp
│   │   └── Visualizer.hpp
│   └── wrapper
│       ├── Wrapper.cpp
│       └── Wrapper.hpp
└── README.md
```

Under this file structure, `colcon list` outputs the below:

```
jbs@jbs:~/ros2_ws$ colcon list
my_package      src/simple-ros2-package/my_package      (cmake)
my_package_ros2 src/simple-ros2-package/my_package_ros2 (ros.ament_cmake)
```

Please note that `my_package` is recognized as `cmake` and `my_package_ros2` as
`ros.ament_cmake`.

### Core library (pure cmake)

In this folder structure, it is assumed that individual core library (library_a
and library_b) will not be treated as a separate CMake project as they are
compiled under a single CMake project (my_package). Anyway, it requires an extra
effort to maintain many `CMakeLists.txt` under every single library folder.

### ROS2 library (ament_cmake)

In case of ROS2 library, it is noteworthy that we have `package.xml` to notify
dependency on `my_package` (core).

```xml {11}
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>my_package_ros2</name>
  <version>0.0.0</version>
  <description>TODO: Package description</description>
  <maintainer email="jbs@todo.todo">jbs</maintainer>
  <license>TODO: License declaration</license>

  <buildtool_depend>ament_cmake</buildtool_depend>
  <depend>my_package</depend>
  ...
</package>
~
```

**This is really important**. If you do not have the `<depend>` tag,
`colcon build` might not reflect the correct build order (`my_package` ->
`my_package_ros2`).

## 3. Writing `CMakeLists.txt`

### Core library

For each library target (shown as `${LIBRARY}` which is either `library_a` or
`library_b`), we perform the below:

```cmake showLineNumbers
...
  add_library(${LIBRARY} SHARED ${LIBRARY_SOURCES} ${LIBRARY_HEADERS})

  install(
    TARGETS ${LIBRARY}
    EXPORT ${LIBRARY}
    LIBRARY DESTINATION lib
    INCLUDES
    DESTINATION include)
  install(FILES ${LIBRARY_HEADERS} DESTINATION include/${LIBRARY})
  export(TARGETS ${LIBRARY}
          FILE "${CMAKE_CURRENT_BINARY_DIR}/${LIBRARY}Config.cmake")

  install(
    EXPORT ${LIBRARY}
    FILE "${LIBRARY}Config.cmake"
    DESTINATION share/${LIBRARY}/cmake)
...
```

#### Install library and headers (L4-L10)

If we do not include L8-L9, the client project (my_package_ros2) cannot find
include directory of library when `find_package(library_a)`. This can be seen by
`colcon build --packages-select my_package_ros2 --event-handlers console_direct+ --cmake-args -DCMAKE_VERBOSE_MAKEFILE=TRUE`

##### When L8-L9 not included, output of `CMAKE_VERBOSE`

```shell {4-5}
[ 16%] Building CXX object CMakeFiles/visualizer.dir/visualizer/Visualizer.cpp.o
/usr/bin/c++  -DDEFAULT_RMW_IMPLEMENTATION=rmw_fastrtps_cpp -DRCUTILS_ENABLE_FAULT_INJECTION -DSPDLOG_COMPILED_LIB

-I/home/jbs/ros2_ws/src/simple-ros2-package/my_package_ros2
-isystem /opt/ros/foxy/include

 -o CMakeFiles/visualizer.dir/visualizer/Visualizer.cpp.o -c /home/jbs/ros2_ws/src/simple-ros2-package/my_package_ros2/visualizer/Visualizer.cpp

In file included from /home/jbs/ros2_ws/src/simple-ros2-package/my_package_ros2/visualizer/Visualizer.cpp:1:
/home/jbs/ros2_ws/src/simple-ros2-package/my_package_ros2/visualizer/Visualizer.hpp:4:10: fatal error: library_a/LibraryA.hpp: No such file or directory
    4 | #include "library_a/LibraryA.hpp"
      |          ^~~~~~~~~~~~~~~~~~~~~~~~

```

##### When included,

```shell {4-6}
[ 16%] Building CXX object CMakeFiles/visualizer.dir/visualizer/Visualizer.cpp.o
/usr/bin/c++  -DDEFAULT_RMW_IMPLEMENTATION=rmw_fastrtps_cpp -DRCUTILS_ENABLE_FAULT_INJECTION -DSPDLOG_COMPILED_LIB

-I/home/jbs/ros2_ws/src/simple-ros2-package/my_package_ros2
-isystem /opt/ros/foxy/include
-isystem /home/jbs/ros2_ws/install/my_package/include

  -o CMakeFiles/visualizer.dir/visualizer/Visualizer.cpp.o -c /home/jbs/ros2_ws/src/simple-ros2-package/my_package_ros2/visualizer/Visualizer.cpp
```

### ROS2 library
