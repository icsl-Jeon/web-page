---
title: Part 1 - Frontend pattern for robotic system with state management
date: 2023-06-19
description:

thumbnail: /images/post14/main.png
keywords: design-pattern, robotics, frontend
---

import Image from "next/image";
import Frontmatter from "../../../components/Frontmatter";
import Comment from "../../../components/Comment";

# Frontend code for robotic system with state management - Part 1

<Frontmatter />

When designing a robotic system, the significance of state and its transition is
often overlooked in comparison to backend processes such as algorithms or
methods.

State management plays a crucial role in governing the system's operations.
Insufficient attention to clean code structure in state management can lead to
significant difficulties, considering the consistent modifications to states and
their transitions during development process.

In the upcoming articles, I will guide you on writing frontend code that is both
manageable and adaptable.

## Two types of events on robotic system

Let's say you are developing a frontend code to operate an autonomous drone for
cinematography (for example, something like [this](https://www.skydio.com/)).

<div className="flex flex-col items-center">
  <Image
    src="/images/post14/dji-controller.png"
    width={500}
    height={500}
    className="my-3"
  />
  <p>**Fig.** Controller of DJI drone</p>
</div>

When building the system, you have to handle two types of events.

### Command events: coming from interaction with users

This system will interact with users with the following orders:

1. Initially, the drone will be on the ground (landed).
2. Then, it will hover when the user signals hovering by pressing button.
3. When the drone is flying at a define height, user can define the target for
   shooting (by dragging a bounding box on the screen).
4. If the user presses mission-start-button, it will try to follow the defined
   target.

First, your frontend code needs to handle these user commands, and reflect them
into drones' motion. That is, if a user requested hover, then the motion
generation should output an elegant upward motion.

Through articles, I will call this type as **command event**.

### Monitor events: to be handled by robots for autonomy

But, what if the drone loses a target during the flight? Should the drone notify
about their failure and wait users? Or, what if battery level is low?

For enhanced autonomy of the system, the drone should be capable of handling
these events on its own. To this end, the autonomous robot should always
**monitor** whether they are doing well, and deal with issues (events) with
**defined logics**.

For example, in response to _TargetLost_ event, the drone should look around to
explore places to re-detect the targets. Or, in reaction to _BatteryLow_ event,
drone should choose to land even without users' command.

Through articles, I will refer to this type as **monitor event**.

### We need a good code design for frontend

<div className="flex flex-col items-center">
  <Image
    src="/images/post14/scenario.png"
    width={1000}
    height={500}
    className="my-3"
  />
  <p>**Fig.** Diagram of the drone system</p>
</div>
In sum, it seems that we have to implement the above diagram. What we have to worry
is that: **there must be a bunch of cases we should consider in the future!** We
have to write a manageable code to reuse our frontend code along the development.

## Pipeline of robotic systems (frontend / backend)

For the ease of further discussion, I first introduce a _model_ to describe a
general robot software stacks including frontend and backend. This model focuses
on state management and omits other functionalities such as
[threading](/threading-ros2) or [adaptors](/design-pattern/post5). This is the
model that I designed from my experience. So, it might have some limitations.

<div className="flex flex-col items-center m-5">
  <Image
    src="/images/post14/pipeline.png"
    width={1000}
    height={500}
    className="my-3"
  />
  <p>**Fig.** Frontend and backend of robotic system </p>
</div>

### Backend

In backend side, there exist core logics to be queried. [OMPL](tools/post13) is
a good example. They reside in the backend of
[moveit](https://moveit.ros.org/documentation/planners/) stacks. In general,
backend classes are member variables of their consumers (=frontend), and the
core logics are queried as
[this code](https://github.com/ros-planning/moveit/blob/69ca441bc343c51544b19dde9c5a095481a3d906/moveit_ros/planning/planning_pipeline/src/planning_pipeline.cpp#LL257C36-L257C36)
illustrates.

In the above figure, backend corresponds to the `Core logics` block. From
frontend, they are requested some to compute a motion plan, from which actuation
inputs can be generated.

Often times, from interface of backends, we can find a strategy pattern or
switch phrases for the logics to be chosen depending on situation (= policy,
state).

### Frontend

<Comment />
